import {
  XPrv,
  Mnemonic,
  createTransactions,
  IUtxoEntry,
  kaspaToSompi,
  PendingTransaction,
  PrivateKeyGenerator,
  RpcClient,
  signTransaction,
  Transaction,
  UtxoContext,
  ScriptBuilder,
  XOnlyPublicKey,
  Address,
  addressFromScriptPublicKey,
} from '@/wasm'
import Addresses from './addresses'
import EventEmitter from 'events'
import KeyManager from '@/wallet/kaspa/KeyManager'
import { Inscription } from '@/wallet/kaspa/krc20/Inscription'
import Account from '@/wallet/kaspa/account/account'

export interface CustomInput {
  address: string
  outpoint: string
  index: number
}

export interface CustomSignature {
  outpoint: string
  index: number
  signer: string
  script?: string
}

export default class Transactions extends EventEmitter {
  kaspa: RpcClient
  context: UtxoContext
  addresses: Addresses
  account: Account | null = null
  encryptedKey: string | undefined
  accountId: number | undefined

  private transactions: Map<string, PendingTransaction> = new Map()

  constructor(kaspa: RpcClient, context: UtxoContext, addresses: Addresses) {
    super()

    this.kaspa = kaspa
    this.context = context
    this.addresses = addresses
  }

  setAccount(account: Account) {
    this.account = account
  }

  async import(encryptedKey: string, accountId: number) {
    this.encryptedKey = encryptedKey
    this.accountId = accountId
  }

  async create(outputs: [string, string][], feeRate: number, fee: string, customs?: CustomInput[]) {
    let priorityEntries: IUtxoEntry[] = []

    if (customs && customs.length > 0) {
      const { entries } = await this.kaspa.getUtxosByAddresses({
        addresses: customs.map((custom) => custom.address),
      })
      for (const custom of customs) {
        const matchingEntry = entries.find(
          ({ outpoint }) =>
            outpoint.transactionId === custom.outpoint && outpoint.index === custom.index,
        )

        if (matchingEntry) {
          priorityEntries.push(matchingEntry)
        } else throw Error('Failed to resolve custom entry')
      }
    }

    const preparedTxn = {
      priorityEntries,
      entries: this.context,
      outputs: outputs.map((output) => ({
        address: output[0],
        amount: kaspaToSompi(output[1])!,
      })),
      changeAddress: this.addresses.changeAddresses[this.addresses.changeAddresses.length - 1],
      feeRate,
      priorityFee: kaspaToSompi(fee)!,
    }
    console.log('[Transactions] create - doing createTransasctions with obj:', preparedTxn)
    console.log('[Transactions] this.context:', this.context)

    const { transactions } = await createTransactions(preparedTxn)

    await this.addresses.increment(0, 1)

    for (const transaction of transactions) {
      this.transactions.set(transaction.id, transaction)
    }

    return transactions.map((transaction) => transaction.serializeToSafeJSON())
  }

  async sign(transactions: string[]) {
    if (!this.encryptedKey) {
      console.error('[Transactions] No imported account available for signing.')
      throw Error('No imported account')
    }

    const decryptedKey = KeyManager.getKey()
    if (!decryptedKey) {
      console.error('[Transactions] No decrypted key available in KeyManager.')
      throw Error('No decrypted key available in KeyManager.')
    }

    const mnemonic = new Mnemonic(decryptedKey)
    const seed = mnemonic.toSeed() // This should be a 64-byte buffer
    const xprv = new XPrv(seed)
    const keyGenerator = new PrivateKeyGenerator(xprv, false, BigInt(this.accountId!))
    const signedTransactions: Transaction[] = []

    for (const transaction of transactions) {
      const parsedTransaction = Transaction.deserializeFromSafeJSON(transaction)
      const privateKeys = []
      for (let address of parsedTransaction.addresses(this.addresses.networkId)) {
        if (address.version === 'ScriptHash') {
          continue
        }
        const [isReceive, index] = this.addresses.findIndexes(address.toString())
        privateKeys.push(isReceive ? keyGenerator.receiveKey(index) : keyGenerator.changeKey(index))
      }

      const signedTransaction = signTransaction(parsedTransaction, privateKeys, false)
      signedTransactions.push(signedTransaction)
    }
    return signedTransactions.map((transaction) => transaction.serializeToSafeJSON())
  }

  async submitContextful(transactions: string[]) {
    const submittedIds: string[] = []

    for (const transaction of transactions) {
      const parsedTransaction = Transaction.deserializeFromSafeJSON(transaction)
      const cachedTransaction = this.transactions.get(parsedTransaction.id)

      if (!cachedTransaction)
        throw Error('Transaction is not generated by wallet, use Node.submit().')

      for (let i = 0; i < parsedTransaction.inputs.length; i++) {
        const input = parsedTransaction.inputs[i]
        cachedTransaction.fillInput(i, input.signatureScript)
      }

      submittedIds.push(await cachedTransaction.submit(this.kaspa))
    }

    this.emit('transaction', transactions[transactions.length - 1])
    return submittedIds
  }

  // Step 1: Commit Transaction
  async commitTransaction(outputs: [string, string][], feeRate: number, fee: string) {
    console.log('[Transactions] Creating commit transaction....')

    const serializedPendingTransactions = await this.create(outputs, feeRate, fee)
    console.log(
      '[Transactions] Serialized Pending Commit Transaction:',
      serializedPendingTransactions,
    )

    const signedTransactions = await this.sign(serializedPendingTransactions)
    console.log('[Transactions] Signed Commit Transaction:', signedTransactions)

    const submittedTransactionIds = await this.submitContextful(signedTransactions)
    console.log(
      '[Transactions] Commit Transaction submitted successfully:',
      submittedTransactionIds,
    )

    return { transactionId: submittedTransactionIds[0], signedTransactions }
  }

  // Step 2: Reveal Transaction
  async revealTransaction(
    recipient: string,
    ticker: string,
    amount: number,
    decimal: number,
    commitTxId: string,
  ) {
    console.log('[Transactions] Revealing transaction with inscription....')

    const inscription = this.buildInscription(recipient, ticker, amount, decimal)

    let script = new ScriptBuilder()
    const senderAddress = this.addresses.receiveAddresses[0]
    const pubKey = XOnlyPublicKey.fromAddress(new Address(senderAddress)).toString()

    inscription.write(script, pubKey)
    console.log('[Transactions] Inscription:', inscription)

    const scriptPublicKey = script.createPayToScriptHashScript()
    const scriptAddress = addressFromScriptPublicKey(
      scriptPublicKey,
      this.addresses.networkId,
    )!.toString()
    console.log('[Transactions] scriptAddress:', scriptAddress)

    const outputs: [string, string][] = [
      [scriptAddress, '0.2'], // KRC20 Inscription output
    ]
    console.log('[Transactions] outputs for reveal:', outputs)

    const fee = '0.0001'
    const feeRate = 1
    const serializedPendingTransactions = await this.create(outputs, feeRate, fee)
    console.log(
      '[Transactions] Serialized Pending Reveal Transaction:',
      serializedPendingTransactions,
    )

    const signedTransactions = await this.sign(serializedPendingTransactions)
    console.log('[Transactions] Signed Reveal Transaction:', signedTransactions)

    const submittedTransactionIds = await this.submitContextful(signedTransactions)
    console.log(
      '[Transactions] Reveal Transaction submitted successfully:',
      submittedTransactionIds,
    )

    return { transactionId: submittedTransactionIds[0] }
  }

  async writeInscription(recipient: string, ticker: string, amount: number, decimal: number) {
    console.log('[Transactions] Writing inscription....')

    const commitOutputs: [string, string][] = [
      [recipient, '0.2'], // Commit a placeholder output
    ]
    const commitResult = await this.commitTransaction(commitOutputs, 1, '0.0001')
    console.log('[Transactions] Commit transaction ID:', commitResult.transactionId)

    const revealResult = await this.revealTransaction(
      recipient,
      ticker,
      amount,
      decimal,
      commitResult.transactionId,
    )
    console.log('[Transactions] Reveal transaction ID:', revealResult.transactionId)

    return { commitTxId: commitResult.transactionId, revealTxId: revealResult.transactionId }
  }

  buildInscription(recipient: string, ticker: string, amount: number, decimal: number) {
    const amountToSend = BigInt(+amount * 10 ** +decimal).toString()
    return new Inscription('transfer', {
      tick: ticker,
      amt: amountToSend,
      to: recipient.toString(),
    })
  }

  reset() {
    delete this.encryptedKey
    delete this.accountId
  }
}
